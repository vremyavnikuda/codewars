# Тема №4 Многомерные массивы - матрицы.

### Вопрос 1 : Запишите последовательность действий для исключения из многомерного массива элемента с заданным значением.

Исключение элемента с заданным значением из многомерного массива в C++ требует нескольких шагов, так как непосредственно
удалить элемент нельзя — вместо этого обычно используется маркировка элемента как `“недействительного”` или перестройка
массива. Вот последовательность действий:

1. Определите значение, которое нужно исключить.
2. Пройдитесь по всем элементам многомерного массива с помощью вложенных циклов.
3. Когда вы находите элемент с заданным значением, вы можете:

-
    - Маркировать его как `“недействительный”`, например, установив специальное значение, которое не будет
      использоваться в дальнейших операциях (например, `INT_MIN` для целочисленных массивов).
-
    - Сдвинуть оставшиеся элементы для заполнения пробела, если порядок элементов не важен.
-
    - Создать новый массив без элемента с заданным значением, если порядок элементов важен.

```cpp
#include <iostream>
#include <climits> // Для INT_MIN

const int INVALID = INT_MIN; // Маркер для недействительных элементов

void excludeValue(int** array, int rows, int cols, int valueToExclude) {
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            if (array[i][j] == valueToExclude) {
                array[i][j] = INVALID; // Маркируем элемент как недействительный
            }
        }
    }
}

int main() {
    const int rows = 3;
    const int cols = 3;
    int valueToExclude = 5;
    int array[rows][cols] = {{5, 2, 3}, {4, 5, 6}, {7, 8, 9}};

    // Преобразуем массив в массив указателей для передачи в функцию
    int* ptrArray[rows];
    for (int i = 0; i < rows; ++i) {
        ptrArray[i] = array[i];
    }

    excludeValue(ptrArray, rows, cols, valueToExclude);

    // Выводим массив после исключения значения
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            if (array[i][j] == INVALID) {
                std::cout << "X "; // Выводим X для недействительных элементов
            } else {
                std::cout << array[i][j] << ' ';
            }
        }
        std::cout << std::endl;
    }

    return 0;
}
```

`excludeValue` ищет и маркирует все элементы с заданным значением 5 как недействительные. В основной программе выводится
измененный массив, где все исключенные элементы отмечены символом X. Если вам нужно физически удалить элементы из
массива, потребуется создать новый массив и скопировать в него только действительные элементы.
___

### Вопрос 2 : Запишите последовательность операторов для добавления элемента в необходимую позицию в многомерном массиве.

Добавление элемента в определенную позицию многомерного массива в C++ непосредственно невозможно, так как размеры
статических массивов фиксированы после их объявления. Однако, работая с динамическим массивом или контейнером
типа `std::vector`, можно изменять его содержимое. Для статических массивов можно только изменить значение существующего
элемента.

Если задача предполагает использование динамического массива или std::vector векторов, то можно добавить элемент
следующим образом:

- Определи позицию, куда нужно добавить элемент.
- Создай новый многомерный динамический массив или вектор векторов с размером на один элемент больше в нужном измерении.
- Скопируй элементы из старого массива в новый, оставляя место для нового элемента.
- Вставь новый элемент в освободившееся место.
- Удали старый массив, если он был динамически выделен.

```cpp
#include <iostream>
#include <vector>

void insertElement(std::vector<std::vector<int>>& matrix, int row, int col, int value) {
    if (row >= matrix.size() || col >= matrix[row].size()) {
        std::cerr << "Позиция за пределами массива." << std::endl;
        return;
    }

    // Вставляем элемент в указанную позицию
    matrix[row].insert(matrix[row].begin() + col, value);
}

int main() {
    std::vector<std::vector<int>> matrix = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };

    int value = 99; // Значение для добавления
    int row = 1;    // Ряд для добавления
    int col = 1;    // Колонка для добавления

    insertElement(matrix, row, col, value);

    // Выводим матрицу после вставки
    for (const auto& row : matrix) {
        for (int elem : row) {
            std::cout << elem << ' ';
        }
        std::cout << std::endl;
    }

    return 0;
} 
```

`insertElement` добавляет элемент `99` в позицию `(1, 1)` двумерного вектора `matrix`. После добавления элемента, все
элементы в ряду сдвигаются на одну позицию вправо, начиная с позиции вставки. Обрати внимание, что векторы в C++
обеспечивают гибкость для таких операций, в отличие от статических массивов.
___

### Вопрос 3 : Каким образом двумерные (многомерные) массивы размещаются в памяти компьютера?

Двумерные (многомерные) массивы в C++ размещаются в памяти компьютера последовательно, один за другим. Это означает, что
элементы массива хранятся в памяти так, как если бы это был одномерный массив. Для двумерного массива, первый индекс
обычно отвечает за строку, а второй — за столбец. При этом элементы одной строки располагаются в памяти последовательно.

Например, если у нас есть двумерный массив `int arr[2][3]`, то он будет представлен в памяти следующим образом:

```cpp
arr[0][0], arr[0][1], arr[0][2], arr[1][0], arr[1][1], arr[1][2]
```

Таким образом, если мы хотим обратиться к элементу `arr[1][2]`, компилятор вычислит его адрес, используя размер типа
данных (`sizeof(int)` в данном случае), количество элементов в строке и индексы. В памяти это будет выглядеть как
обращение к элементу одномерного массива по смещению, рассчитанному на основе этих параметров.

Для многомерных массивов логика аналогична, но с дополнительными измерениями. Каждое новое измерение добавляет уровень
вложенности в расчет адреса элемента. Все элементы многомерного массива также хранятся в памяти последовательно.
___

### Вопрос 4 : Как определить объем памяти, отводимой под многомерный массив?

Объем памяти, отводимый под многомерный массив в C++, можно определить, умножив размер всех измерений массива на размер
типа элемента массива. Для статически выделенного многомерного массива формула для расчета объема памяти выглядит
следующим образом:

$$Объем_памяти = sizeof(тип_элемента)n_1\cdot n_2\cdot ...\cdot n_k $$

где `n_1`, `n_2`, `...`, `n_k` — размеры измерений массива, а `k` — количество измерений.

Например, если у вас есть двумерный массив `int arr[10][20]`, то объем памяти, который он занимает, будет:

$$Объем\:памяти\:=\:sizeof\left(int\right)\cdot 10\cdot 20$$

В этом случае, если `sizeof(int)` равен `4 байтам`, то массив `arr` займет:

$$4\:байта\:\cdot \:10\cdot 20=800\:байт$$

Для динамически выделенных многомерных массивов, таких как массивы указателей, объем памяти будет включать как память, выделенную для хранения указателей, так и память, выделенную для хранения самих элементов массива. В таком случае расчет будет сложнее и должен учитывать размеры всех указателей и размеры всех массивов, на которые они указывают.