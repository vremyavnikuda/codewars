### Выберете все неверные утверждения

#### Динамическое распределение памяти используется когда :

1.Размер и количество используемых структур данных определяется на этапе компиляции программы
2.Типы и состав элементов используемых структур данных заранее неизвестны
3.Необходимо изменять требуемый объем памяти в соответствии с потребностями программы
4.Заранее неизвестна размерность обрабатываемых данных
5.Используются рекурсивные структуры данных

> Ответ: 2,3,4,5

---

#### Дополните определение

**\_\_** - другое имя уже существующего объекта

1.идентификатор
2.указатель
3.адресная переменная
4.переменная
5.ссылка

> Ответ: ссылка - другое имя уже существующего объекта

---

### Дополните определение

#### Для освобождения динамически выделенной памяти в языке С++ используется операция

1.free
2.clear
3.delete
4.default

> Ответа: delete

---

### Написать программу ,содержащую рекурсивныую функцию на языке Си,которой передается один ,параметр k- количество вводимых целых чисел

Ответ предоставить в виде
1.Определения рекурсивной функции с комментариями.
2.Не менее трех наборов тестовых данных для модульного тестирования
Задание:Найти наибольшее из отрицательных значений во вводимой последовательности из k-целых числе.Ответ вернуть как результат работы функции.

```cpp
#include <limits.h>
#include <stdio.h>
// Рекурсивная функция для нахождения наибольшего отрицательного значения
int findMaxNegative(int k)
{
    // Базовый случай ,если k==0 ,возвращаем минимальное значение целого числа
    if (k == 0)
    {
        return INT_MIN;
    }

    int num;
    printf("Введите число:");
    scanf("%d", &num);

    // Рекурсивный вызов функции для оставшихся чисел (k-1)
    int maxNegative = findMaxNegative(k - 1);
    // Если текущее число отрицательное и больше текущего максимального отрицательного числа
    if (num < 0 && num > maxNegative)
    {
        return num;
    }
    return maxNegative;
}

int main()
{
    int k;
    printf("Введите количество чисел: ");
    scanf("%d", &k);

    int maxNegative = findMaxNegative(k);

    if (maxNegative == INT_MIN)
    {
        printf("В последовательности нет отрицательных чисел.\n");
    }
    else
    {
        printf("Наибольшее из отрицательных чисел: %d\n", maxNegative);
    }
    return 0;
}
```

> Набор данных 1:
> Вводимые числа: 3, -1, -4, 2, -2
> Ожидаемый результат: -1

---

> Набор данных 2:
> Вводимые числа: 5, 8, 12, 7, 10
> Ожидаемый результат: В последовательности нет отрицательных чисел.

---

> Набор данных 3:
> Вводимые числа: 4, -6, -3, -8, -1
> Ожидаемый результат: -1

---

### Выберите операции ,которые неприменимы к указателю pnt:

char \*pnt[N]

1.Инкремент,декремент
2.Использование операции sizeof(указатель) для получения размера памяти,необходимого для указателя
3.Сложение указателей
4.Получение адреса указателя
5.Вычитание указателей
6.Инициализация указателей
7.Сложение(вычитание) указателя и целого числа
8.Разыменование указателя

> `Ответ`:
>
> -   Сложение указателей
> -   Вычитание указателей

---

### Дополните определение

#### Динамические переменные не имеют имени,доступ к ним осуществляется через

1.косвенную адресацию
2.элемент данных
3.указатель
4.ссылку
5.адрес

> Ответ: `указатель`

---

### Выберите все неверные утверждения

#### Переменная вида int \*pnt , в соответствии к контектным определением может быть:

1.Указателем на область памяти ,отведенную под элементы целочисленной матрицы
2.Константным указателем на переменную целого числа
3.Указателем на указатель на переменную типа int
4.Указателем на скалярную переменную типа int
5.Указателем на массив элементов целого типа

> Ответ:
>
> -   Константным указателем на переменную целого числа
> -   Указателем на указатель на переменную типа int

---

### Написать рекурсивную функцию обхода дерева и поиска значения соответствии с вариантом задания .Ответ вернуть как результат работы функции.

```cpp
struct bTree
{
    int value;
    bTree *left,*right;
};
```

Задание : В бинарном дереве определить кол-во чисел,которые являются степенями заданного числа k.

#### Ответ:

```cpp
#include <math.h>
#include <iostream>
//Структура определена в задании
struct bTree
{
    int value;
    bTree *left, *right;
};

// Функция для проверки ,является ли чисто степенью числа k
bool ifPowerOf(int num, int k)
{
    if (num < 1)
        return false;
    double logResult = log(num) / log(k);

    return floor(logResult) == logResult;
}

// Рекурсивная функция для обхода дерева и подсчета чисел , являющихся степенями числа k.
int countPowersOfK(bTree *root, int k)
{
    if (root == NULL)
        return 0;

    int count = 0;
    if (ifPowerOf(root->value, k))
    {
        count = 1;
    }

    count += countPowersOfK(root->left, k);
    count += countPowersOfK(root->right, k);

    return count;
}

int main()
{
    bTree *root = new bTree{16, NULL, NULL};
    root->left = new bTree{4, NULL, NULL};
    root->right = new bTree{2, NULL, NULL};
    root->left->left = new bTree{64, NULL, NULL};
    root->left->right = new bTree{8, NULL, NULL};

    int k = 2;
    int result = countPowersOfK(root, k);
    std::cout << "Количество чисел, являющихся степенями " << k << ": " << result << std::endl;

    // Освобождение памяти
    delete root->left->left;
    delete root->left->right;
    delete root->left;
    delete root->right;
    delete root;

    return 0;
}
```

---

### Выберите все правильные варианты ответов

#### Двоичное дерево поиска - это ориентирное дерево ,в котором:

1.Из каждой вершины выходит не менее двух ребер
2.Используя включения элемента в бинарное дерево ,можно отсортировать входную последовательность данных по выбранному ключу.
3.В каждую вершину ,включая корень,входит одно ребро
4.Из каждой вершины ,включая корень ,выходит не менее трех ребер.
5.Значение в любом узле его левого поддерева меньше ,а правого поддерева - больше значения в его родительском узле.
6.Имеется ровно одна вершина ,в которую не входит ни одного ребра - это корень дерева.

> Ответы:
    - Используя включения элемента в бинарное дерево, можно отсортировать входную последовательность данных по выбранному ключу.
    - В каждую вершину, включая корень, входит одно ребро.
    - Значение в любом узле его левого поддерева меньше, а правого поддерева — больше значения в его родительском узле.
    - Имеется ровно одна вершина, в которую не входит ни одного ребра — это корень дерева.
---

### Установите соответствие между Фрагментами программ и Способами формирования структур данных :
```cpp

```